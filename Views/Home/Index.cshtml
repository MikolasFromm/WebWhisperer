@{
    ViewData["Title"] = "Whisper App";
}
<style>
    #dropdown div:hover, #dropdown div.selected {
        background-color: green; /* Change the background color on hover or when selected */
    }

    .ai-suggestion {
        background-color: orange;
    }

    #dropdown
    {
        position: absolute;
        top: 100%;
        left: 0;
        display: none;
        border: 1px solid #ccc;
        background-color: white;
    }

    .outputFieldClass input {
        width: 100%;
        border: none;
        outline: none;
    }

    .inputFieldClass input {
        width: 100%;
        border: none;
        outline: none;
        border-bottom: 1px solid #000;
    }

    #UserInputHeading
    {
        padding: 5px;
        padding-bottom: 80px;
        padding-top: 30px
    }
</style>

<center>
    <h2 style="padding: 10px">NaturalSQL Parser</h2>
</center>

<table style="width: 100%">
    <colgroup>
        <col span="1" style="width: 10%;">
        <col span="1" style="width: 90%;">
    </colgroup>
    <tbody>
        <tr>
            <td id="UserInputHeading">User query: </td>
            <td style="padding-bottom: 80px; padding-top: 30px">
                <div class="inputFieldClass">
                    <input id="inputField" type="text" oninput="uploadNewUserQuery()" />
                </div>
            </td>
        </tr>
        <tr>
            <td style="padding: 5px">Query builder: </td>
            <td>
                <div style="position: relative;">
                    <div class="outputFieldClass"><input id="outputField" type="text" oninput="whisperNextMove()" />
                    </div>
                    <div id="dropdown">
                    </div>
                </div>
            </td>
        </tr>
    </tbody>
</table>

<script>
    // get the field of the output element
    const queryBuilder = document.getElementById("outputField");
    let querySoFar = queryBuilder.value;
    let dotIndex = -1; // Define dotIndex at a higher scope

    let nextMoves = [];

    async function uploadNewUserQuery() 
    {
        // Get the user input
        const userInput = document.getElementById("inputField").value;

        // get the last character
        const lastChar = userInput.slice(-1);

        // when user input ends with ".", send it to the server
        if (lastChar === ".")
        {
            // Send the user input to the server
            const response = await fetch('/api/whisper/upload', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(userInput)
            });

            whisperNextMove();

            // Get the first possible whisper from the server
        }
    }

    async function whisperNextMove() 
    {
        // get the dropdown element
        const dropdown = document.getElementById("dropdown");
        // Clear previous dropdown options
        dropdown.innerHTML = "";

        // get the query build so far
        querySoFar = queryBuilder.value;
        // get the last character
        const lastChar = querySoFar.slice(-1);
        // Calculate the position of the last dot character
        dotIndex = querySoFar.lastIndexOf(".");
        // Get the prefix after the last "."
        const prefix = querySoFar.slice(dotIndex + 1);

        // if lastChar is ".", whisped next move
        if (lastChar === "." || querySoFar === "")
        {
            // send request to build all next moves
            const response = await fetch('/api/whisper/process', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(querySoFar)
            });

            nextMoves = await response.json();
        }

        // Filter the available next moves based on the prefix
        const filteredMoves = nextMoves.filter(move => move.startsWith(prefix));

        if (filteredMoves.length > 0) {

            // Calculate the position to place the dropdown
            const inputRect = queryBuilder.getBoundingClientRect();
            const inputLeft = getTextWidth(querySoFar.slice(0, dotIndex), queryBuilder);
            const inputTop = inputRect.bottom;

            // Position the dropdown element
            dropdown.style.display = "block";
            dropdown.style.left = `${inputLeft}px`;

            // create dropdown element for each next move
            dropdown.style.display = "block";
            filteredMoves.forEach((move, index) => {
                const option = document.createElement("div");
                option.innerText = move;

                option.style.cursor = "pointer";
                option.style.padding = "5px"; // extra padding

                // Set background color for the first item
                if (index === 0) {
                    option.classList.add("ai-suggestion");
                }

                option.addEventListener("click", () => {
                    const prefix = querySoFar.slice(0, dotIndex + 1); // Prefix before the "."
                    queryBuilder.value = prefix + move; // Replace existing text after "."
                    dropdown.style.display = "none";
                });

                dropdown.appendChild(option);
            });
        } 
        // remove dropdown menu when writing text
        else
        {
            dropdown.style.display = "none";
        }
    }

    // Function to calculate the width of a given text within an element
    function getTextWidth(text, element) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        context.font = window.getComputedStyle(element).font;
        return context.measureText(text).width;
    }


    // Function to update the visual selection state
    function updateSelection() {
        const dropdownOptions = document.querySelectorAll("#dropdown div");
        dropdownOptions.forEach((option, index) => {
            if (index === selectedOptionIndex) {
                option.classList.add("selected");
            } else {
                option.classList.remove("selected");
            }
        });
    }

    let selectedOptionIndex = -1;

    // Add keydown event listener to handle navigation and selection
    document.addEventListener("keydown", (event) => {
        const dropdownOptions = document.querySelectorAll("#dropdown div");

        if (event.key === "ArrowDown") {
            // Navigate down
            selectedOptionIndex = (selectedOptionIndex + 1) % dropdownOptions.length;
            updateSelection();
        } else if (event.key === "ArrowUp") {
            // Navigate up
            selectedOptionIndex = (selectedOptionIndex - 1 + dropdownOptions.length) % dropdownOptions.length;
            updateSelection();
        } else if (event.key === "Enter") {
            // Select option
            if (selectedOptionIndex >= 0 && selectedOptionIndex < dropdownOptions.length) {
                const prefix = querySoFar.slice(0, dotIndex + 1); // Prefix before the "."
                const selectedMove = dropdownOptions[selectedOptionIndex].innerText;
                queryBuilder.value = prefix + selectedMove; // Replace existing text after "."
                dropdown.style.display = "none";
            }
        }
    });

</script>
